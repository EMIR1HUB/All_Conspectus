a# Вложенные запросы

### Содержание <br>
[Вложенный запрос, возвращающий одно значение](#T1)<br>
[Использование вложенного запроса в выражении](#T2)<br>
[Вложенный запрос, оператор IN](#T3)<br>
[Вложенный запрос, операторы ANY и ALL](#T4)<br>
[Вложенный запрос после SELECT](#T5)<br>

<br>

SQL позволяет создавать вложенные запросы (подзапросы, внутренние запросы) - это запрос внутри другого запроса SQL.

Вложенный запрос используется для выборки данных, которые будут использоваться в условии отбора записей основного запроса. Его применяют для:

* сравнения выражения с результатом вложенного запроса;
* определения того, включено ли выражение в результаты вложенного запроса;
* проверки того, выбирает ли запрос определенные строки.

Вложенный запрос имеет следующие компоненты:

* ключевое слово `SELECT`  после которого указываются имена столбцов или выражения (чаще всего список содержит один элемент) ;
* ключевое слово `FROM` и имя таблицы, из которой выбираются данные;
* необязательное предложение `WHERE`;
* необязательное предложение `GROUP BY`:
* необязательное предложение `HAVING`.

 > Вложенные запросы  могут включаться в WHERE или HAVING так (в квадратных скобках указаны необязательные элементы, через | – один из элементов):
>* `WHERE | HAVING` выражение оператор_сравнения (вложенный запрос);
>* `WHERE | HAVING` выражение, включающее вложенный запрос;
>* `WHERE | HAVING` выражение [NOT] IN (вложенный запрос);
>* `WHERE | HAVING` выражение  оператор_сравнения  ANY | ALL (вложенный запрос)

Также вложенные запросы могут вставляться в основной запрос после ключевого слова `SELECT`.

Запросы формулируются для таблицы `book` ([создание, заполнение](https://github.com/EMIR1HUB/All_Conspectus/blob/main/SQL/1_base_Table.md))
___


<br><a name="T1"></a> 
# Вложенный запрос, возвращающий одно значение

Можно использовать в условии отбора записей `WHERE` как обычное значение совместно с операциями =, <>, >=, <=, >, <

#### **Пример** Вывести информацию о самых дешевых книгах, хранящихся на складе.

Для реализации запроса необходимо получить минимальную цену из столбца `price` таблицы `book`, а затем вывести информацию о тех книгах, цена которых  равна минимальной. Первая часть  – поиск  минимума, реализуется вложенным запросом.

```SQL
SELECT title, author, price, amount
FROM book
WHERE price = (
         SELECT MIN(price) 
         FROM book
      );

--результат
+-------+------------------+--------+--------+
| title | author           | price  | amount |
+-------+------------------+--------+--------+
| Идиот | Достоевский Ф.М. | 460.00 | 10     |
+-------+------------------+--------+--------+
```

#### **Пример** Вывести информацию (автора, название и цену) о  книгах, цены которых меньше или равны средней цене книг. Информацию вывести в отсортированном по убыванию цены виде. Среднее вычислить как среднее по цене книги.

```SQL
SELECT author, title, price
FROM book
WHERE price <= (
        SELECT AVG(price)
        FROM book
    )
ORDER BY price DESC;

--результат
+------------------+---------------+--------+
| author           | title         | price  |
+------------------+---------------+--------+
| Булгаков М.А.    | Белая гвардия | 540.50 |
| Достоевский Ф.М. | Игрок         | 480.50 |
| Достоевский Ф.М. | Идиот         | 460.00 |
+------------------+---------------+--------+
```
___

<br><a name="T2"></a>
# Использование вложенного запроса в выражении

Вложенный запрос, возвращающий одно значение, может использоваться в выражениях как обычный операнд, например, к нему можно что-то прибавить, вычесть и пр.

#### **Пример** Вывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3. (нужно вывести те книги, кол. экземпляров которых < среднего на 3, или > среднего на 3).

```SQL
SELECT title, author, amount 
FROM book
WHERE ABS(amount - (
    SELECT AVG(amount) 
    FROM book)
    ) > 3;

--результат
+-----------------------+------------------+--------+
| title                 | author           | amount |
+-----------------------+------------------+--------+
| Мастер и Маргарита    | Булгаков М.А.    | 3      |
| Братья Карамазовы     | Достоевский Ф.М. | 3      |
| Стихотворения и поэмы | Есенин С.А.      | 15     |
+-----------------------+------------------+--------+
```

#### **Пример** Вывести информацию (автора, название и цену) о тех книгах, цены которых превышают минимальную цену книги на складе не более чем на 150 рублей в отсортированном по возрастанию цены.

```SQL
SELECT author, title, price
FROM book
WHERE price <= (
    SELECT MIN(price)
    FROM book) + 150
ORDER BY price ASC;

--результат
+------------------+----------------+--------+
| author           | title          | price  |
+------------------+----------------+--------+
| Достоевский Ф.М. | Идиот          | 460.00 |
| Достоевский Ф.М. | Игрок          | 480.50 |
| Булгаков М.А.    | Белая гвардия  | 540.50 |
| Пушкин А.С.      | Евгений Онегин | 610.00 |
+------------------+----------------+--------+
```
___

<br><a name="T3"></a>
# Вложенный запрос, оператор IN

Вложенный запрос может возвращать несколько значений одного столбца.  Тогда его можно использовать в разделе WHERE совместно с оператором `IN`.

`WHERE имя_столбца IN (вложенный запрос, возвращающий один столбец)`

Оператор `IN` определяет, совпадает ли значение столбца с одним из значений, содержащихся во вложенном запросе. При этом логическое выражение после `WHERE` получает значение истина. Оператор `NOT IN` выполняет обратное действие – выражение истинно, если значение столбца не содержится во вложенном запросе.

#### **Пример** Вывести информацию о книгах тех авторов, общее количество экземпляров книг которых не менее 12.

```SQL
SELECT title, author, amount, price
FROM book
WHERE author IN (
        SELECT author 
        FROM book 
        GROUP BY author 
        HAVING SUM(amount) >= 12
      );

--результат
+-----------------------+------------------+--------+--------+
| title                 | author           | amount | price  |
+-----------------------+------------------+--------+--------+
| Идиот                 | Достоевский Ф.М. | 10     | 460.00 |
| Братья Карамазовы     | Достоевский Ф.М. | 3      | 799.01 |
| Игрок                 | Достоевский Ф.М. | 10     | 480.50 |
| Стихотворения и поэмы | Есенин С.А.      | 15     | 650.00 |
+-----------------------+------------------+--------+--------+
```

#### **Пример** Вывести информацию (автора, книгу и количество) о тех книгах, количество экземпляров которых в таблице `book` не дублируется.

```SQL
SELECT author, title, amount
FROM book
WHERE amount IN (
    SELECT amount
    FROM book
    GROUP BY amount
    HAVING COUNT(amount) = 1
    );

--результат
+---------------+-----------------------+--------+
| author        | title                 | amount |
+---------------+-----------------------+--------+
| Булгаков М.А. | Белая гвардия         | 5      |
| Есенин С.А.   | Стихотворения и поэмы | 15     |
+---------------+-----------------------+--------+
```
___

<br><a name="T4"></a>
# Вложенный запрос, операторы ANY и ALL

 Вложенный запрос, возвращающий несколько значений одного столбца, можно использовать для отбора записей с помощью операторов `ANY` и `ALL` совместно с операциями отношения (=, <>, <=, >=, <, >).

Операторы `ANY` и `ALL` используются  в SQL для сравнения некоторого значения с результирующим набором вложенного запроса, состоящим из одного столбца. При этом тип данных столбца, возвращаемого вложенным запросом, должен совпадать с типом данных столбца (или выражения), с которым происходит сравнение.

При использовании оператора `ANY` в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно хотя бы для одного элемента результирующего запроса. Оператор `ANY`:

* `amount > ANY (10, 12)` эквивалентно amount > 10

* `amount < ANY (10, 12)` эквивалентно amount < 12

* `amount = ANY (10, 12`) эквивалентно (amount = 10) OR (amount = 12), а также amount IN  (10,12)

* `amount <> ANY (10, 12)` вернет все записи с любым значением amount, включая 10 и 12

При использовании оператора `ALL` в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно для всех элементов результирующего запроса. Оператор `ALL`:

* `amount > ALL (10, 12)` эквивалентно amount > 12

* `amount < ALL (10, 12)` эквивалентно amount < 10

* `amount = ALL (10, 12)` не вернет ни одной записи, так как эквивалентно (amount = 10) AND (amount = 12)
  
* `amount <> ALL (10, 12)` вернет все записи кроме тех,  в которыхamount равно 10 или 12

> **Важно!** Операторы `ALL` и `ANY` можно использовать только с вложенными запросами. В примерах выше (10, 12) приводится как результат вложенного запроса. В запросах так записывать нельзя.

#### **Пример** Вывести информацию о тех книгах, количество которых меньше самого маленького среднего количества книг каждого автора.

```SQL
SELECT title, author, amount, price
FROM book
WHERE amount < ALL (
        SELECT AVG(amount) 
        FROM book 
        GROUP BY author 
      );

--результат
+--------------------+------------------+--------+--------+
| title              | author           | amount | price  |
+--------------------+------------------+--------+--------+
| Мастер и Маргарита | Булгаков М.А.    | 3      | 670.99 |
| Братья Карамазовы  | Достоевский Ф.М. | 3      | 799.01 |
+--------------------+------------------+--------+--------+
```
> В этом примере `amount < ALL ( 4.0000, 7.6667, 15.0000)`  означает, что подходят все `amount` меньше 4.0000 из списка.<br>
> Таким образом, наш запрос отобрал все книги книги **Мастер и Маргарита** и **Братья Карамазовы**, количество которых равно 3. 

#### **Пример** Вывести информацию о тех книгах, количество которых меньше самого большого среднего количества книг каждого автора.

```SQL
SELECT title, author, amount, price
FROM book
WHERE amount < ANY (
        SELECT AVG(amount) 
        FROM book 
        GROUP BY author 
      );

--результат
+--------------------+------------------+--------+--------+
| title              | author           | amount | price  |
+--------------------+------------------+--------+--------+
| Мастер и Маргарита | Булгаков М.А.    | 3      | 670.99 |
| Белая гвардия      | Булгаков М.А.    | 5      | 540.50 |
| Идиот              | Достоевский Ф.М. | 10     | 460.00 |
| Братья Карамазовы  | Достоевский Ф.М. | 3      | 799.01 |
| Игрок              | Достоевский Ф.М. | 10     | 480.50 |
+--------------------+------------------+--------+--------+

```

> В этом примере `amount < ANY ( 4.0000, 7.6667, 15.0000)`  означает, что подходят `amount` меньше самого большого значения из списка.

#### **Пример** Вывести информацию о книгах(автор, название, цена), цена которых меньше самой большой из минимальных цен, вычисленных для каждого автора.

```SQL
SELECT author, title, price
FROM book
WHERE price < ANY(
    SELECT MIN(price)
    FROM book
    GROUP BY author
    );

--результат
+------------------+---------------+--------+
| author           | title         | price  |
+------------------+---------------+--------+
| Булгаков М.А.    | Белая гвардия | 540.50 |
| Достоевский Ф.М. | Идиот         | 460.00 |
| Достоевский Ф.М. | Игрок         | 480.50 |
+------------------+---------------+--------+
```
___

<br><a name="T5"></a>
# Вложенный запрос после SELECT

Вложенный запрос может располагаться после ключевого слова `SELECT`. В этом случае результат выполнения запроса выводится в отдельном столбце результирующей таблицы. При этом результатом запроса может быть только одно значение, тогда оно будет повторяться во всех строках. Также вложенный запрос может использоваться в выражениях.

#### **Пример** Вывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3,  а также указать среднее значение количества экземпляров книг.

```SQL
SELECT title, author, amount, 
    (
     SELECT AVG(amount) 
     FROM book
    ) AS Среднее_количество 
FROM book
WHERE abs(amount - (SELECT AVG(amount) FROM book)) >3;

--результат
+-----------------------+------------------+--------+--------------------+
| title                 | author           | amount | Среднее_количество |
+-----------------------+------------------+--------+--------------------+
| Мастер и Маргарита    | Булгаков М.А.    | 3      | 7.6667             |
| Братья Карамазовы     | Достоевский Ф.М. | 3      | 7.6667             |
| Стихотворения и поэмы | Есенин С.А.      | 15     | 7.6667             |
+-----------------------+------------------+--------+--------------------+
```
Во вложенном запросе вычисляется среднее количество экземпляров книг на складе. Значения  столбца одинаковы во всех строках, поскольку  вложенный запрос возвращает одно значение.

Среднее количество в виде дробного числа выглядит не очень правильно. Полученное значение можно округлить "вниз" - до ближайшего меньшего целого.

```SQL
SELECT title, author, amount, 
      FLOOR(
          (SELECT AVG(amount) 
          FROM book)
          ) 
      AS Среднее_количество 
FROM book
WHERE ABS(amount - (SELECT AVG(amount) FROM book)) >3;

--результат
+-----------------------+------------------+--------+--------------------+
| title                 | author           | amount | Среднее_количество |
+-----------------------+------------------+--------+--------------------+
| Мастер и Маргарита    | Булгаков М.А.    | 3      | 7                  |
| Братья Карамазовы     | Достоевский Ф.М. | 3      | 7                  |
| Стихотворения и поэмы | Есенин С.А.      | 15     | 7                  |
+-----------------------+------------------+--------+--------------------+
```
___
